# 인덱스 (Index)
- 인덱스를 쓰는 이유는 무엇일까?
- 인덱스는 어느 상황에 쓰는 게 적절한가?

<br>

## 인덱스란?
- 테이블의 동작 속도를 높여주는 자료 구조를 일컫는다. ⇒ 데이터베이스 튜닝에 사용!
- 인덱스는 테이블 내의 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성된다.
- 정렬(순서 매김 동작)에 주로 사용될 수 있다.
- 그런데 인덱스를 저장하는 데에는 디스크 공간이 필요하다 ⇒ <K, V> 쌍이 파일로 저장된다.
    - 대개 테이블을 저장하는 데 필요한 디스크 공간보다는 작다.
- RDBMS에서는 테이블 부분에 대한 하나의 사본으로 작용한다.
- 인덱스는 고유 제약 조건을 실현하기 위해서도 사용된다. 고유 인덱스는 중복된 항목이 등록되는 것을 방지하기 때문이다. ⇒ 고유성 보장

<br>

### 📌 인덱스의 남발
- 회원 정보 테이블에, 아이디와 비밀번호와 이메일과 이름 컬럼이 존재한다고 해보자.
- 위 네 가지 컬럼은 모두 필수 요소이지만, NOT NULL은 아이디에만 걸어두었다. 왜 그래야 할까?
    - NOT NULL을 걸면 예외가 발생하기 때문에 프로그램에서 **별도의 Exception 처리를 많이 해야한다.** 따라서 위 컬럼들의 NULL 처리는 서버(어플리케이션) 단에서 처리한다.
    - **제약 조건을 걸면 무조건 인덱스가 생성**되며, 불필요한 인덱스가 생성된다면 **디스크 공간을 차지**하기 때문에 성능 저하를 유발할 수가 있다. 따라서 적절한 중간을 찾는 게 중요하다.
- 어떤 성능 저하가 있을까?
    1. 데이터의 변경 작업이 자주 일어나는 경우에 성능 측면에서 불리해진다.
    2. 처음 인덱스를 생성하는 데 많은 시간이 소요된다.
    3. 인덱스를 참조하는 게 전체 테이블을 찾는 것보다 느릴 수 있다.
    4. DB 공간을 10%가량 더 차지한다.

<br>

## 인덱스의 종류

### 📌 클러스터형 인덱스 (Clustered Index)

- 일련의 나열된 데이터들을 **일정 기준으로 정렬**해주는 인덱스
- 테이블 당 하나만 생성 가능하다.
- 클러스터형 인덱스는 생성 시에 데이터 페이지 전체가 다시 정렬된다.
    - 따라서 이미 대용량의 데이터가 입력된 상태라면 심각한 부하가 발생할 수 있다.
- 테이블을 만들 때 생성되며, 어느 열에 클러스터형 인덱스를 생성하는 지에 따라 시스템의 성능이 달라진다.
- 보조 인덱스보다 검색 속도는 빠르지만, 입력&수정&삭제가 느리다.
- MySQL의 경우 Primary Key가 있다면 Primary Key를 클러스터형 인덱스로 지정한다.
    - 없다면 Unique하면서 Not Null인 컬럼을 쓰고, 그것도 없다면 임의로 보이지 않는 컬럼을 만들어 클러스터형 인덱스로 지정한다.

<br>

### 📌 보조 인덱스 (Secondary Index)
- 데이터와 인덱스를 각각 다른 위치에 저장한다.
- 인덱스는 해당 데이터의 위치에 대한 포인터를 포함하고 있다.
- 테이블 당 여러 개 생성 가능하다. (너무 많이 생성하면 성능 저하)
- 개념적으로 후보키에만 부여 가능한 인덱스이다.
    - 후보키 : 주민번호과 같이, 각 데이터를 인식할 수 있는 최소한의 **고유 식별 단위(집합)**
- 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 구성한다. ⇒ 재정렬 X
- 클러스터형 인덱스보다 검색 속도는 느리지만, 입력&수정&삭제의 성능 부하가 적다.

<br>

## 인덱스 생성 전략
- 데이터 변경 작업이 얼마나 자주 일어나는 지를 고려해야 한다.
- 인덱스는 검색을 빠르게 하기 위한 자료구조이기 때문에, **where절에서 자주 사용하는 열**(검색이 잦은 열)**에 생성**한다.
- 데이터 중복도가 높은 열에는 인덱스를 만들어도 효과가 없다. **⇒ 중복도가 낮은 열에 생성한다.**
- 마찬가지로 **조인에 자주 사용되는 열**에는 인덱스를 생성하는 것이 좋다.
- 외래키를 설정한 열에는 자동으로 외래키 인덱스가 생성되며, 클러스터형 인덱스는 테이블 당 하나만 생성할 수 있다.
- 클러스터드 인덱스는 검색 속도가 $O(logN)$ 이고 보조 인덱스는 $O(2 * logN)$이라 대체로 클러스터드가 검색속도가 더 빠르다.
- 사용하지 않는 인덱스가 있다면 **메모리 공간을 위해 제거**해준다.

<br>

## 인덱스의 실제 적용
- Index_type : BTREE
    - B-Tree에 어떻게 저장될까? ⇒ [링크 참고](https://dataonair.or.kr/db-tech-reference/d-guide/da-guide/?pageid=1&mod=document&keyword=%EC%9D%B8%EB%8D%B1%EC%8A%A4&uid=297)
- 클러스터형 인덱스가 없다면 데이터는 삽입한 순서로 저장된다. 반대로, 있다면 데이터가 정렬되어 저장된다. select 문에서 별도의 order by를 쓸 필요는 없다.
- 이미 테이블에 중복값이 있다면 별도의 unique 인덱스를 못 만든다.
- **Execution plan 메뉴**에서 쿼리의 성능을 볼 수 있다. 같은 컬럼을 검색하더라도 인덱스의 유무나 PK의 참조 여부에 따라서 시간이 다르기 때문에 **가능한 cost가 작은 방법**을 쓰는 게 좋다. **⇒ 성능 튜닝!**

<br>

### 출처
- 개인 필기